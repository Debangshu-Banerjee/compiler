%{


#include <bits/stdc++.h>
#include "structure_def.h"

using namespace std;

extern int yylex();
extern int yylineno;
void yyerror(string s){
	 cerr<< s <<"at line no "<< yylineno<< endl;
}
int global_temp = 0;
code_output intermediate_output;
sym_tab symbol_table;
int level = 0;
int active_function_index = 0;  // -1 for any type error

%}

%union{
  char *name;          // name of a variable or function
  int integer_value;   // value of an integer
  float real_value;    // value of a real number
  int type;            // check the define -1 for int -2 float and so on
  N_* N_s;
  M_ * M_s;
  ifexp_ * ifexp_s;
  loopexp_ * loopexp_s;
  varlist_ * varlist_s;
  id_arr_ * id_arr_s;
  id_arr_declare_ * id_arr_declare_s;
  type_ * type_s;
  elist_ * elist_s;
  conditional_expression_ * conditional_expression_s;
  parameter_list_ * parameter_list_s;
  assignment_statement_ * assignment_statement_s;
  statement_list_ * statement_list_s;
  result_ * result_s;
  new_num_list_ * new_num_list_s;
  unit_declaration_ * unit_declaration_s;
}
%token ELSE FOR IF RETURN WHILE PTR_OP INC_OP DEC_OP AND_OP OR_OP LT GT LE_OP GE_OP EQ_OP NE_OP DO BREAK LIBRARY CONTINUE ERROR
%token NOT AMP TILDE STAR ASSIGN OPEN_BRACKET CLOSE_BRACKET OPEN_CURLY CLOSE_CURLY OPEN_SQUARE CLOSE_SQUARE
%token SEMI COMMA DOT PLUS MINUS DIVIDE MODULUS PIPE XOR QUES COLON
%token <name> ID
%token <type> BOOL CHAR INT FLOAT VOID
%token <integer_value> NUM
%token <real_value> REAL

%nonassoc "IFX"
%nonassoc ELSE

%left OR_OP
%left AND_OP
%left EQ_OP NE_OP
%left GT
%left LT
%left PLUS MINUS
%left STAR DIVIDE
%right NOT
%right UMINUS
%right INC_OP DEC_OP

%type<N_s> N
%type<M_s> M
%type<ifexp_s> ifexp
%type<loopexp_s> whileexp forexp
%type<varlist_s> varlist         // no constructor
%type<id_arr_s> id_arr
%type<type_s> type
%type<elist_s> elist   // no constructor
%type<conditional_expression_s> conditional_expression expression rel_expression normal_expression term factor unary_expression primary_expression
%type<parameter_list_s> parameter_list param_decl
%type<assignment_statement_s> assignment_statement
%type<statement_list_s> statement_list statement selection_statement iteration_statement // no constructor
%type<result_s> res_id
%type<new_num_list_s> new_num_list
%type<id_arr_declare_s> id_arr_declare
%type<unit_declaration_s> unit_declaration

%%

program: statement_list;


function_declaration: function_head first_curly statement_list last_curly;

first_curly: OPEN_CURLY { level++;}
            ;

last_curly: CLOSE_CURLY;

function_head: res_id OPEN_BRACKET parameter_list CLOSE_BRACKET;

res_id: type ID {
	cout<< "find a function \n";
    string s($2);
    if(symbol_table.search_func(s) != -1){
      $$ = new result_(ERROR_TYPE);
      yyerror("this function is declared previously\n");
      active_function_index = -1;
    }
    else{
        $$ = new result_($1->type);
        active_function_index = symbol_table.add_function(s,$1->type);
        level = 1;
        string new_s = "func_" + s + ":";
        intermediate_output.gen(new_s);
    }
}
        ;

type: INT    {$$ = new type_(INT_TYPE);}
      |FLOAT {$$ = new type_(FLOAT_TYPE);}
      |VOID {$$ = new type_(VOID_TYPE);}
      ;

statement_list: statement_list M statement
                | /* empty */ ;

statement: variable_declaration SEMI
          |RETURN SEMI
          |RETURN conditional_expression SEMI
          |selection_statement
          |iteration_statement
          |assignment_statement SEMI
          |first_curly statement_list last_curly
          | function_declaration;

selection_statement: ifexp  statement   ELSE N M statement
                    |ifexp  statement %prec "IFX";

/* switch case statement left */

ifexp: IF OPEN_BRACKET assignment_statement CLOSE_BRACKET;

iteration_statement: whileexp statement
                    |forexp assignment_statement CLOSE_BRACKET statement;

whileexp: WHILE M OPEN_BRACKET assignment_statement CLOSE_BRACKET;

forexp: FOR OPEN_BRACKET assignment_statement SEMI M assignment_statement SEMI;

M: /*empty*/;

N: /*empty*/ ;

conditional_expression: conditional_expression AND_OP expression
{

 	int temp_type = get_compatible_type_bool_only($1->type,$3->type);
 	$$ = new conditional_expression_(temp_type);
 	std::ostringstream out;
 	if(temp_type != ERROR_TYPE){
	 	out << " && " << $1->temporary_name <<"     "<<$3->temporary_name << $$->temporary_name;
	 	string s = out.str();
	 	intermediate_output.gen(s);
 	}
	else{
		if($1->type != ERROR_TYPE && $3->type != ERROR_TYPE){
				yyerror("Expected boolean data types for both operand");
		}
	}
}
                        |conditional_expression OR_OP expression
{
 	int temp_type = get_compatible_type_bool_only($1->type,$3->type);
 	$$ = new conditional_expression_(temp_type);
 	std::ostringstream out;
 	if(temp_type != ERROR_TYPE){
	 	out << " || " << $1->temporary_name <<"     "<<$3->temporary_name << $$->temporary_name;
	 	string s = out.str();
	 	intermediate_output.gen(s);
 	}
	else{
		if($1->type != ERROR_TYPE && $3->type != ERROR_TYPE){
				yyerror("Expected boolean data types for both operand");
		}
	}
}

                        |expression
{
	$$ = new conditional_expression_($1->type);
	std::ostringstream out;
	if($1->type != ERROR_TYPE){
		out << " = " << $1->temporary_name << " --- " << $$->temporary_name;
		string s = out.str();
		intermediate_output.gen(s);
	}
}

												;

expression: rel_expression
{
	$$ = new conditional_expression_($1->type);
	std::ostringstream out;
	if($1->type != ERROR_TYPE){
		out << " = " << $1->temporary_name << " --- " << $$->temporary_name;
		string s = out.str();
		intermediate_output.gen(s);
	}
}
          |normal_expression
{
	$$ = new conditional_expression_($1->type);
	std::ostringstream out;
	if($1->type != ERROR_TYPE){
		out << " = " << $1->temporary_name << " --- " << $$->temporary_name;
		string s = out.str();
		intermediate_output.gen(s);
	}
}
					;

rel_expression: normal_expression GT normal_expression
{
	int temp_type = get_compatible_type_rel_op($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		out << " > " << $1->temporary_name <<"     "<<$3->temporary_name << $$->temporary_name;
		string s = out.str();
		intermediate_output.gen(s);
	}
	else{
		if($1->type != ERROR_TYPE &&  $3->type != ERROR_TYPE){
			if($1->type == BOOL_TYPE &&  $3->type != BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
			if($1->type != BOOL_TYPE &&  $3->type == BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
		}
	}

}

                |normal_expression LT normal_expression

{
	int temp_type = get_compatible_type_rel_op($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		out << " < " << $1->temporary_name <<"     "<<$3->temporary_name << $$->temporary_name;
		string s = out.str();
		intermediate_output.gen(s);
	}
	else{
		if($1->type != ERROR_TYPE &&  $3->type != ERROR_TYPE){
			if($1->type == BOOL_TYPE &&  $3->type != BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
			if($1->type != BOOL_TYPE &&  $3->type == BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
		}
	}

}

                |normal_expression GE_OP normal_expression
{
	int temp_type = get_compatible_type_rel_op($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		out << " >= " << $1->temporary_name <<"     "<<$3->temporary_name << $$->temporary_name;
		string s = out.str();
		intermediate_output.gen(s);
	}
	else{
		if($1->type != ERROR_TYPE &&  $3->type != ERROR_TYPE){
			if($1->type == BOOL_TYPE &&  $3->type != BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
			if($1->type != BOOL_TYPE &&  $3->type == BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
		}
	}

}

                |normal_expression LE_OP normal_expression
{
	int temp_type = get_compatible_type_rel_op($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		out << " <= " << $1->temporary_name <<"     "<<$3->temporary_name << $$->temporary_name;
		string s = out.str();
		intermediate_output.gen(s);
	}
	else{
		if($1->type != ERROR_TYPE &&  $3->type != ERROR_TYPE){
			if($1->type == BOOL_TYPE &&  $3->type != BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
			if($1->type != BOOL_TYPE &&  $3->type == BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
		}
	}

}
                |normal_expression EQ_OP normal_expression
{
	int temp_type = get_compatible_type_rel_op($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		out << " == " << $1->temporary_name <<"     "<<$3->temporary_name << $$->temporary_name;
		string s = out.str();
		intermediate_output.gen(s);
	}
	else{
		if($1->type != ERROR_TYPE &&  $3->type != ERROR_TYPE){
			if($1->type == BOOL_TYPE &&  $3->type != BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
			if($1->type != BOOL_TYPE &&  $3->type == BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
		}
	}

}
                |normal_expression NE_OP normal_expression
{
	int temp_type = get_compatible_type_rel_op($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		out << " != " << $1->temporary_name <<"     "<<$3->temporary_name << $$->temporary_name;
		string s = out.str();
		intermediate_output.gen(s);
	}
	else{
		if($1->type != ERROR_TYPE &&  $3->type != ERROR_TYPE){
			if($1->type == BOOL_TYPE &&  $3->type != BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
			if($1->type != BOOL_TYPE &&  $3->type == BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
		}
	}
}
								;

normal_expression: normal_expression PLUS term
{
	int temp_type = get_compatible_type_non_bool($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		out << " + " << $1->temporary_name <<"     "<<$3->temporary_name << $$->temporary_name;
		string s = out.str();
		intermediate_output.gen(s);
	}
	else{
		if($1->type == BOOL_TYPE &&  $3->type == BOOL_TYPE){
			yyerror("Trying to add with a boolean data type");
		}
	}
}
                  |normal_expression MINUS term
{
	int temp_type = get_compatible_type_non_bool($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		out << " - " << $1->temporary_name <<"     "<<$3->temporary_name << $$->temporary_name;
		string s = out.str();
		intermediate_output.gen(s);
	}
	else{
		if($1->type == BOOL_TYPE &&  $3->type == BOOL_TYPE){
			yyerror("Trying to subtract with a boolean data type");
		}
	}
}

                  |term
{
	$$ = new conditional_expression_($1->type);
	std::ostringstream out;
	if($1->type != ERROR_TYPE){
		out << " = " << $1->temporary_name << " --- " << $$->temporary_name;
		string s = out.str();
		intermediate_output.gen(s);
	}
}

									;

term: term STAR factor
{
	int temp_type = get_compatible_type_non_bool($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		out << " * " << $1->temporary_name <<"     "<<$3->temporary_name << $$->temporary_name;
		string s = out.str();
		intermediate_output.gen(s);
	}
	else{
		if($1->type == BOOL_TYPE &&  $3->type == BOOL_TYPE){
			yyerror("Trying to multiply with a boolean data type");
		}
	}
}
      |term DIVIDE factor
{
	int temp_type = get_compatible_type_non_bool($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		out << " / " << $1->temporary_name <<"     "<<$3->temporary_name << $$->temporary_name;
		string s = out.str();
		intermediate_output.gen(s);
	}
	else{
		if($1->type == BOOL_TYPE &&  $3->type == BOOL_TYPE){
		 	yyerror("Trying to divide with a boolean data type");
		}
	}
}

      |factor
{
	$$ = new conditional_expression_($1->type);
	std::ostringstream out;
	if($1->type != ERROR_TYPE){
		out << " = " << $1->temporary_name << " --- " << $$->temporary_name;
		string s = out.str();
		intermediate_output.gen(s);
	}

}

			;

factor: unary_expression
{
	$$ = new conditional_expression_($1->type);
	std::ostringstream out;
	if($1->type != ERROR_TYPE){
		out << " = " << $1->temporary_name << " --- " << $$->temporary_name;
		string s = out.str();
		intermediate_output.gen(s);
	}
}
;

unary_expression: primary_expression
{
	$$ = new conditional_expression_($1->type);
	std::ostringstream out;
	if($1->type != ERROR_TYPE ){
			out << " = " << $1->temporary_name << " --- " << $$->temporary_name;
			string s = out.str();
			intermediate_output.gen(s);
	}

}
                |MINUS unary_expression %prec UMINUS
{
	if($2->type != BOOL_TYPE){
		$$ = new conditional_expression_($2->type);
		std::ostringstream out;
		if($2->type != ERROR_TYPE ){
			out << " UMINUS " << $2->temporary_name << " --- " << $$->temporary_name;
			string s = out.str();
			intermediate_output.gen(s);
		}
	}
	else{
		yyerror("Trying to negate a boolean data type");
		$$ = new conditional_expression_(ERROR_TYPE);
	}
}
                |NOT unary_expression
{
	std::ostringstream out;
	if($2->type == FLOAT_TYPE ){
		$$ = new conditional_expression_(ERROR_TYPE);
		yyerror("can not use not operator on a float data type");
	}
	else{
				$$ = new conditional_expression_($2->type);
		}
	if($2->type != ERROR_TYPE && $2->type != FLOAT_TYPE ){
				out << " NOT " << $2->temporary_name << " --- " << $$->temporary_name;
				string s = out.str();
				intermediate_output.gen(s);
		}
}
                |DEC_OP unary_expression
{
	if($2->type != BOOL_TYPE){
		$$ = new conditional_expression_($2->type);
		std::ostringstream out;
		if($2->type != ERROR_TYPE){
			out << " - " << $2->temporary_name << " 1 " << $$->temporary_name;
			string s = out.str();
			intermediate_output.gen(s);
		}
	}
	else{
		yyerror("Trying to decrement a boolean data type");
		$$ = new conditional_expression_(ERROR_TYPE);
	}

}
                |INC_OP unary_expression
{
	if($2->type != BOOL_TYPE){
		$$ = new conditional_expression_($2->type);
		std::ostringstream out;
		if($2->type != ERROR_TYPE){
			out << " + " << $2->temporary_name << " 1 " << $$->temporary_name;
			string s = out.str();
			intermediate_output.gen(s);
		}
	}
	else{
		yyerror("Trying to increment a boolean data type");
		$$ = new conditional_expression_(ERROR_TYPE);
	}

}

								;

primary_expression: NUM
{
$$ = new conditional_expression_(INT_TYPE);
std::ostringstream out;
out << " = " << $1 << " --- " << $$->temporary_name;
string s = out.str();
intermediate_output.gen(s);
}

                    |REAL
{
$$ = new conditional_expression_(FLOAT_TYPE);
std::ostringstream out;
out << " = " << $1 << " --- " << $$->temporary_name;
string s = out.str();
intermediate_output.gen(s);
}

                    | id_arr
{
	if($1->var == NULL){
			yyerror("The used variable is not declared");
			$$ = new conditional_expression_(ERROR_TYPE);
	}
	else{
			$$ = new conditional_expression_($1->var->eletype);
			std::ostringstream out;
			out << " = " << $1->var->name <<"_"<< $1->var->offset << " --- " << $$->temporary_name;
			string s = out.str();
			intermediate_output.gen(s);
	}

}
                    |OPEN_BRACKET conditional_expression CLOSE_BRACKET
{
  $$ = new conditional_expression_($2->type,$2->temporary_name);
}
										;

										//******************************
                   /* --------------- function call has to be added -----------*/

elist: elist OPEN_SQUARE expression CLOSE_SQUARE
      |OPEN_SQUARE expression CLOSE_SQUARE;

assignment_statement: id_arr ASSIGN conditional_expression
					  |	conditional_expression
					  | /* empty */
					  ;

variable_declaration: type varlist
{
	if(active_function_index != -1 ){
		symbol_table.patch_variable(active_function_index,$2->list_of_indexes,$1->type);
 	}
}

;

id_arr: ID
{
}
      |ID elist
{
}
			;

/* storing -1 in place of index be careful */
id_arr_declare : ID {
  if(active_function_index != -1){
      string s($1);
      variable * v_temp = symbol_table.search_variable_current(active_function_index,s,level);
      vector<int> v;
      v.clear();
      if(v_temp == NULL){
          int index = symbol_table.add_variable(active_function_index,s,SIMPLE,v,level);
          $$ = new id_arr_declare_(index);
      }
      else{
          if(v_temp->level_of_declaration != level){
              if(level != 2){
                  int index = symbol_table.add_variable(active_function_index,s,SIMPLE,v,level);
                  $$ = new id_arr_declare_(index);
              }
              else{
                  if(symbol_table.search_parameter(active_function_index,s) == false){
                    int index = symbol_table.add_variable(active_function_index,s,SIMPLE,v,level);
                    $$ = new id_arr_declare_(index);
                  }
                  else{
                      yyerror("This variable is defined in this scope previously");
                      $$ = new id_arr_declare_(-1);
                  }
              }
          }
          else{
              yyerror("This variable is defined in this scope previously");
              $$ = new id_arr_declare_(-1);
          }
      }
  }
}
                | ID new_num_list{
if(active_function_index != -1){
      string s($1);
      variable * v_temp = symbol_table.search_variable_current(active_function_index,s,level);
      vector<int> v;
      v.clear();
      v = $2-> num_list;
      if(v_temp == NULL){
          int index = symbol_table.add_variable(active_function_index,s,ARRAY,v,level);
          $$ = new id_arr_declare_(index);
      }
      else{
          if(v_temp->level_of_declaration != level){
              if(level != 2){
                  int index = symbol_table.add_variable(active_function_index,s,ARRAY,v,level);
                  $$ = new id_arr_declare_(index);
              }
              else{
                  if(symbol_table.search_parameter(active_function_index,s) == false){
                    int index = symbol_table.add_variable(active_function_index,s,ARRAY,v,level);
                    $$ = new id_arr_declare_(index);
                  }
                  else{
                      yyerror("This variable is defined in this scope previously");
                      $$ = new id_arr_declare_(-1);
                  }
              }
          }
          else{
              yyerror("This variable is defined in this scope previously");
              $$ = new id_arr_declare_(-1);
          }
      }
  }
}

                ;

new_num_list : new_num_list  OPEN_SQUARE NUM CLOSE_SQUARE {
			cout<<"Trying to reduce new num list\n";
      $$  = new new_num_list_();
      $$->num_list.insert($$->num_list.end(),$1->num_list.begin(),$1->num_list.end());
      $$->num_list.push_back($3);
}
               | OPEN_SQUARE NUM CLOSE_SQUARE
{
		cout<<"Trying to reduce new num list\n";
    $$  = new new_num_list_();
    $$->num_list.push_back($2);
}
               ;

parameter_list: param_decl
							{ $$ = new parameter_list_($1->no_of_parameter);
								symbol_table.patch_function_parameter_no(active_function_index,$$->no_of_parameter);
							}
              |/*empty*/
							{ $$ = new parameter_list_(0);
							 symbol_table.patch_function_parameter_no(active_function_index,$$->no_of_parameter);
							}
              ;

param_decl: param_decl COMMA unit_declaration

{
if(active_function_index != -1){
	 if($3->type != ERROR_TYPE){
	 $$ = new parameter_list_($1->no_of_parameter + 1);;
	 }
	 else{
	  	$$ = new parameter_list_($1->no_of_parameter);
	 }
}
}


          |unit_declaration
{
if(active_function_index != -1){
	 if($1->type != ERROR_TYPE){
	 $$ = new parameter_list_(1);
	 }
	 else{
	  	$$ = new parameter_list_(0);
	 }
}
}
          ;

unit_declaration: type ID
{
	if(active_function_index != -1){
		string s($2);
		if(symbol_table.search_parameter(active_function_index,s) == false ){
			int index = symbol_table.add_parameter(active_function_index,s,SIMPLE,$1->type);
			$$ = new unit_declaration_ ($1->type);
		}
		else{
			yyerror("This parameter has been passed early");
			$$ = new unit_declaration_ (ERROR_TYPE);
			}
	}
}
                |type ID OPEN_SQUARE CLOSE_SQUARE
{
if(active_function_index != -1){
	string s($2);
	if(symbol_table.search_parameter(active_function_index,s) == false ){
		int index = symbol_table.add_parameter(active_function_index,s,ARRAY,$1->type);
		$$ = new unit_declaration_ ($1->type);
	}
	else{
			yyerror("This parameter has been passed early");
			$$ = new unit_declaration_ (ERROR_TYPE);
	}
}
}
               ;

varlist: varlist COMMA id_arr_declare{
	  $$ = new varlist_();
		$$->list_of_indexes.insert($$->list_of_indexes.end(),$1->list_of_indexes.begin(),$1->list_of_indexes.end());
		$$->list_of_indexes.push_back($3->index_in_sym_tab);
}
        |id_arr_declare{
          $$ = new varlist_();
		  $$->list_of_indexes.push_back($1->index_in_sym_tab);
        }

        ;

%%
#include <stdio.h>

int main(){

	yyparse();
  symbol_table.display();
	intermediate_output.print();
}
