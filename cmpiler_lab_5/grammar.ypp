%{


#include <bits/stdc++.h>
#include "structure_def.h"

using namespace std;

extern int yylex();
extern int yylineno;
void yyerror(string s){
	 cerr<< s <<"at line no "<< yylineno<< endl;
}
int global_temp = 0;
code_output intermediate_output;
sym_tab symbol_table;
int level = 0;
int active_function_index = 0;  // -1 for any type error

%}

%union{
  char *name;          // name of a variable or function 
  int integer_value;   // value of an integer
  float real_value;    // value of a real number 
  int type;            // check the define -1 for int -2 float and so on 
  N_* N_s;
  M_ * M_s;
  ifexp_ * ifexp_s;
  loopexp_ * loopexp_s;
  varlist_ * varlist_s;
  id_arr_ * id_arr_s;
  type_ * type_s;
  elist_ * elist_s;
  conditional_expression_ * conditional_expression_s;
  parameter_list_ * parameter_list_s;
  assignment_statement_ * assignment_statement_s;
  statement_list_ * statement_list_s;
  result_ * result_s;
}  
%token ELSE FOR IF RETURN WHILE PTR_OP INC_OP DEC_OP AND_OP OR_OP LT GT LE_OP GE_OP EQ_OP NE_OP DO BREAK LIBRARY CONTINUE ERROR
%token NOT AMP TILDE STAR ASSIGN OPEN_BRACKET CLOSE_BRACKET OPEN_CURLY CLOSE_CURLY OPEN_SQUARE CLOSE_SQUARE
%token SEMI COMMA DOT PLUS MINUS DIVIDE MODULUS PIPE XOR QUES COLON
%token <name> ID
%token <type> BOOL CHAR INT FLOAT VOID
%token <integer_value> NUM
%token <real_value> REAL

%nonassoc "IFX"
%nonassoc ELSE

%left OR_OP
%left AND_OP
%left EQ_OP NE_OP
%left GT
%left LT
%left PLUS MINUS
%left STAR DIVIDE
%right NOT
%right UMINUS
%right INC_OP DEC_OP

%type<N_s> N
%type<M_s> M
%type<ifexp_s> ifexp
%type<loopexp_s> whileexp forexp
%type<varlist_s> varlist         // no constructor
%type<id_arr_s> id_arr
%type<type_s> type
%type<elist_s> elist   // no constructor
%type<conditional_expression_s> conditional_expression expression rel_expression normal_expression term factor unary_expression primary_expression
%type<parameter_list_s> parameter_list param_decl
%type<assignment_statement_s> assignment_statement
%type<statement_list_s> statement_list statement selection_statement iteration_statement // no constructor
%type<result_s> res_id

%%

program: statement_list;
              

function_declaration: function_head first_curly statement_list last_curly;

first_curly: OPEN_CURLY { printf("level incremented\n");}
            ;

last_curly: CLOSE_CURLY;

function_head: res_id OPEN_BRACKET parameter_list CLOSE_BRACKET;

res_id: type ID { 
    string s($2);
    if(symbol_table.search_func(s) != -1){
      $$ = new result_(ERROR_TYPE);
      yyerror("this function is declared previously\n");
      active_function_index = -1;
    }
    else{
        $$ = new result_($1->type);
        active_function_index = symbol_table.add_function(s,$1->type);
        level = 1;
    }
}
        ;

type: INT    {$$ = new type_(INT_TYPE);}
      |FLOAT {$$ = new type_(FLOAT_TYPE);}
      |VOID {$$ = new type_(VOID_TYPE);}
      ;

statement_list: statement_list M statement
                | /* empty */ ;

statement: variable_declaration SEMI
          |RETURN SEMI
          |RETURN conditional_expression SEMI
          |selection_statement
          |iteration_statement
          |assignment_statement SEMI
          |first_curly statement_list last_curly
          | function_declaration;

selection_statement: ifexp  statement   ELSE N M statement
                    |ifexp  statement %prec "IFX";

/* switch case statement left */

ifexp: IF OPEN_BRACKET assignment_statement CLOSE_BRACKET;

iteration_statement: whileexp statement
                    |forexp assignment_statement CLOSE_BRACKET statement;

whileexp: WHILE M OPEN_BRACKET assignment_statement CLOSE_BRACKET;

forexp: FOR OPEN_BRACKET assignment_statement SEMI M assignment_statement SEMI;

M: /*empty*/;

N: /*empty*/ ;

conditional_expression: conditional_expression AND_OP expression
                        |conditional_expression OR_OP expression
                        |expression;

expression: rel_expression
          |normal_expression;

rel_expression: normal_expression GT normal_expression
                |normal_expression LT normal_expression
                |normal_expression GE_OP normal_expression
                |normal_expression LE_OP normal_expression
                |normal_expression EQ_OP normal_expression
                |normal_expression NE_OP normal_expression;

normal_expression: normal_expression PLUS term
                  |normal_expression MINUS term
                  |term;

term: term STAR factor
      |term DIVIDE factor
      |factor;

factor: unary_expression;

unary_expression: primary_expression
                |MINUS unary_expression
                |NOT unary_expression
                |DEC_OP unary_expression
                |INC_OP unary_expression;

primary_expression: NUM
                    |REAL
                    | id_arr
                    |OPEN_BRACKET conditional_expression CLOSE_BRACKET;
                   /* --------------- function call has to be added -----------*/ 	

elist: elist OPEN_SQUARE expression CLOSE_SQUARE
      |OPEN_SQUARE expression CLOSE_SQUARE;

assignment_statement: id_arr ASSIGN conditional_expression
					  |	conditional_expression	
					  | /* empty */
					  ;

variable_declaration: type varlist;

id_arr: ID
      |ID elist;


parameter_list: param_decl
              |/*empty*/;

param_decl: param_decl COMMA unit_declaration
          |unit_declaration;

unit_declaration: type ID
                |type ID OPEN_SQUARE CLOSE_SQUARE;

varlist: varlist COMMA id_arr
        |id_arr;

%%
#include <stdio.h>

int main(){
	
	yyparse();
}        
