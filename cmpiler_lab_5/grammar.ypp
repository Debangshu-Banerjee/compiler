%{


#include <bits/stdc++.h>
#include "structure_def.h"

using namespace std;

extern int yylex();
extern int yylineno;
void yyerror(string s){
	 cerr<< s <<"at line no "<< yylineno<< endl;
}
int global_temp = 0;
code_output intermediate_output;
sym_tab symbol_table;
int level = 0;
int active_function_index = 0;  // -1 for any type error

%}

%union{
  char *name;          // name of a variable or function 
  int integer_value;   // value of an integer
  float real_value;    // value of a real number 
  int type;            // check the define -1 for int -2 float and so on 
  N_* N_s;
  M_ * M_s;
  ifexp_ * ifexp_s;
  loopexp_ * loopexp_s;
  varlist_ * varlist_s;
  id_arr_ * id_arr_s;
  id_arr_declare_ * id_arr_declare_s;
  type_ * type_s;
  elist_ * elist_s;
  conditional_expression_ * conditional_expression_s;
  parameter_list_ * parameter_list_s;
  assignment_statement_ * assignment_statement_s;
  statement_list_ * statement_list_s;
  result_ * result_s;
  new_num_list_ * new_num_list_s;
}  
%token ELSE FOR IF RETURN WHILE PTR_OP INC_OP DEC_OP AND_OP OR_OP LT GT LE_OP GE_OP EQ_OP NE_OP DO BREAK LIBRARY CONTINUE ERROR
%token NOT AMP TILDE STAR ASSIGN OPEN_BRACKET CLOSE_BRACKET OPEN_CURLY CLOSE_CURLY OPEN_SQUARE CLOSE_SQUARE
%token SEMI COMMA DOT PLUS MINUS DIVIDE MODULUS PIPE XOR QUES COLON
%token <name> ID
%token <type> BOOL CHAR INT FLOAT VOID
%token <integer_value> NUM
%token <real_value> REAL

%nonassoc "IFX"
%nonassoc ELSE

%left OR_OP
%left AND_OP
%left EQ_OP NE_OP
%left GT
%left LT
%left PLUS MINUS
%left STAR DIVIDE
%right NOT
%right UMINUS
%right INC_OP DEC_OP

%type<N_s> N
%type<M_s> M
%type<ifexp_s> ifexp
%type<loopexp_s> whileexp forexp
%type<varlist_s> varlist         // no constructor
%type<id_arr_s> id_arr
%type<type_s> type
%type<elist_s> elist   // no constructor
%type<conditional_expression_s> conditional_expression expression rel_expression normal_expression term factor unary_expression primary_expression
%type<parameter_list_s> parameter_list param_decl
%type<assignment_statement_s> assignment_statement
%type<statement_list_s> statement_list statement selection_statement iteration_statement // no constructor
%type<result_s> res_id
%type<new_num_list_s> new_num_list
%type<id_arr_declare_s> id_arr_declare

%%

program: statement_list;
              

function_declaration: function_head first_curly statement_list last_curly;

first_curly: OPEN_CURLY { level++;}
            ;

last_curly: CLOSE_CURLY;

function_head: res_id OPEN_BRACKET parameter_list CLOSE_BRACKET;

res_id: type ID { 
    string s($2);
    if(symbol_table.search_func(s) != -1){
      $$ = new result_(ERROR_TYPE);
      yyerror("this function is declared previously\n");
      active_function_index = -1;
    }
    else{
        $$ = new result_($1->type);
        active_function_index = symbol_table.add_function(s,$1->type);
        level = 1;
        string new_s = "func_" + s + ":";
        intermediate_output.gen(new_s);
    }
}
        ;

type: INT    {$$ = new type_(INT_TYPE);}
      |FLOAT {$$ = new type_(FLOAT_TYPE);}
      |VOID {$$ = new type_(VOID_TYPE);}
      ;

statement_list: statement_list M statement
                | /* empty */ ;

statement: variable_declaration SEMI
          |RETURN SEMI
          |RETURN conditional_expression SEMI
          |selection_statement
          |iteration_statement
          |assignment_statement SEMI
          |first_curly statement_list last_curly
          | function_declaration;

selection_statement: ifexp  statement   ELSE N M statement
                    |ifexp  statement %prec "IFX";

/* switch case statement left */

ifexp: IF OPEN_BRACKET assignment_statement CLOSE_BRACKET;

iteration_statement: whileexp statement
                    |forexp assignment_statement CLOSE_BRACKET statement;

whileexp: WHILE M OPEN_BRACKET assignment_statement CLOSE_BRACKET;

forexp: FOR OPEN_BRACKET assignment_statement SEMI M assignment_statement SEMI;

M: /*empty*/;

N: /*empty*/ ;

conditional_expression: conditional_expression AND_OP expression
                        |conditional_expression OR_OP expression
                        |expression;

expression: rel_expression
          |normal_expression;

rel_expression: normal_expression GT normal_expression
                |normal_expression LT normal_expression
                |normal_expression GE_OP normal_expression
                |normal_expression LE_OP normal_expression
                |normal_expression EQ_OP normal_expression
                |normal_expression NE_OP normal_expression;

normal_expression: normal_expression PLUS term
                  |normal_expression MINUS term
                  |term;

term: term STAR factor
      |term DIVIDE factor
      |factor;

factor: unary_expression;

unary_expression: primary_expression
                |MINUS unary_expression
                |NOT unary_expression
                |DEC_OP unary_expression
                |INC_OP unary_expression;

primary_expression: NUM
                    |REAL
                    | id_arr
                    |OPEN_BRACKET conditional_expression CLOSE_BRACKET;
                   /* --------------- function call has to be added -----------*/ 	

elist: elist OPEN_SQUARE expression CLOSE_SQUARE
      |OPEN_SQUARE expression CLOSE_SQUARE;

assignment_statement: id_arr ASSIGN conditional_expression
					  |	conditional_expression	
					  | /* empty */
					  ;

variable_declaration: type varlist;

id_arr: ID{
}
      |ID elist;

/* storing -1 in place of index be careful */
id_arr_declare : ID {
  if(active_function_index != -1){
      string s($1);
      variable * v_temp = symbol_table.search_variable_current(active_function_index,s,level);
      vector<int> v;
      v.clear();
      if(v_temp == NULL){
          int index = symbol_table.add_variable(active_function_index,s,SIMPLE,v,level);
          $$ = new id_arr_declare_(index);
      }
      else{
          if(v_temp->level_of_declaration != level){
              if(level != 2){
                  int index = symbol_table.add_variable(active_function_index,s,SIMPLE,v,level);
                  $$ = new id_arr_declare_(index);
              }
              else{
                  if(symbol_table.search_parameter(active_function_index,s) == false){
                    int index = symbol_table.add_variable(active_function_index,s,SIMPLE,v,level);
                    $$ = new id_arr_declare_(index);
                  }
                  else{
                      yyerror("This variable is defined in this scope previously");
                      $$ = new id_arr_declare_(-1);
                  }
              }
          }
          else{
              yyerror("This variable is defined in this scope previously");
              $$ = new id_arr_declare_(-1);
          }
      } 
  }     
}
                | ID new_num_list{
if(active_function_index != -1){
      string s($1);
      variable * v_temp = symbol_table.search_variable_current(active_function_index,s,level);
      vector<int> v;
      v.clear();
      v = $2-> num_list;
      if(v_temp == NULL){
          int index = symbol_table.add_variable(active_function_index,s,ARRAY,v,level);
          $$ = new id_arr_declare_(index);
      }
      else{
          if(v_temp->level_of_declaration != level){
              if(level != 2){
                  int index = symbol_table.add_variable(active_function_index,s,ARRAY,v,level);
                  $$ = new id_arr_declare_(index);
              }
              else{
                  if(symbol_table.search_parameter(active_function_index,s) == false){
                    int index = symbol_table.add_variable(active_function_index,s,ARRAY,v,level);
                    $$ = new id_arr_declare_(index);
                  }
                  else{
                      yyerror("This variable is defined in this scope previously");
                      $$ = new id_arr_declare_(-1);
                  }
              }
          }
          else{
              yyerror("This variable is defined in this scope previously");
              $$ = new id_arr_declare_(-1);
          }
      } 
  }
}                

                ;

new_num_list : new_num_list  OPEN_SQUARE NUM CLOSE_SQUARE {
      $$->num_list.insert($$->num_list.end(),$1->num_list.begin(),$1->num_list.end());
      $$->num_list.push_back($3);
}
               | OPEN_SQUARE NUM CLOSE_SQUARE {
    $$->num_list.push_back($2);     
}
               ;                   

parameter_list: param_decl
              |/*empty*/;

param_decl: param_decl COMMA unit_declaration
          |unit_declaration;

unit_declaration: type ID
                |type ID OPEN_SQUARE CLOSE_SQUARE;

varlist: varlist COMMA id_arr_declare
        |id_arr_declare;

%%
#include <stdio.h>

int main(){
	
	yyparse();
}        
