%{


#include <bits/stdc++.h>
#include "structure_def.h"

using namespace std;

extern int yylex();
extern int yylineno;

int global_temp = 0;
code_output intermediate_output;
loop_tag_genarator loop_tag;
conditional_tag_genator condition_tag;
func_end_tag_genarator func_end_tag;
sym_tab symbol_table;
int level = 0;
int active_function_index = 0;  // -1 for any type error
int call_function_index = -1;
bool main_flag = false;
bool total_error = false;
void yyerror(string s){
	total_error = true;
	 cerr<< s <<" at line no "<< yylineno<< endl;
}
%}

%union{
  char *name;          // name of a variable or function
  int integer_value;   // value of an integer
  float real_value;    // value of a real number
  int type;            // check the define -1 for int -2 float and so on
  N_* N_s;
  M_ * M_s;
  ifexp_ * ifexp_s;
  loopexp_ * loopexp_s;
  varlist_ * varlist_s;
  id_arr_ * id_arr_s;
  id_arr_declare_ * id_arr_declare_s;
  type_ * type_s;
  elist_ * elist_s;
  conditional_expression_ * conditional_expression_s;
  parameter_list_ * parameter_list_s;
  assignment_statement_ * assignment_statement_s;
  statement_list_ * statement_list_s;
  result_ * result_s;
  new_num_list_ * new_num_list_s;
  unit_declaration_ * unit_declaration_s;
	elist_func_call_ * elist_func_call_s;
	case_name_ * case_name_s;
	case_list_ * case_list_s;
	unary_expression_ * unary_expression_s;
}
%token ELSE FOR IF RETURN WHILE PTR_OP INC_OP DEC_OP AND_OP OR_OP LT GT LE_OP GE_OP EQ_OP NE_OP DO BREAK LIBRARY CONTINUE ERROR
%token NOT AMP TILDE STAR ASSIGN OPEN_BRACKET CLOSE_BRACKET OPEN_CURLY CLOSE_CURLY OPEN_SQUARE CLOSE_SQUARE
%token SEMI COMMA DOT PLUS MINUS DIVIDE MODULUS PIPE XOR QUES COLON
%token SWITCH CASE DEFAULT
%token <name> ID
%token <type> BOOL CHAR INT FLOAT VOID
%token <integer_value> NUM
%token <real_value> REAL
%nonassoc "IFS"
%nonassoc DEFAULT CASE
%nonassoc "IFX"
%nonassoc ELSE

%left OR_OP
%left AND_OP
%left EQ_OP NE_OP
%left GT
%left LT
%left PLUS MINUS
%left STAR DIVIDE
%right NOT
%right UMINUS
%right INC_OP DEC_OP

%type<N_s> N
%type<M_s> M N_new
%type<ifexp_s> ifexp
%type<loopexp_s> whileexp forexp
%type<varlist_s> varlist         // no constructor
%type<id_arr_s> id_arr
%type<type_s> type
%type<elist_s> elist   // no constructor
%type<conditional_expression_s> conditional_expression expression rel_expression normal_expression term factor  func_call
%type<parameter_list_s> parameter_list param_decl
%type<assignment_statement_s> assignment_statement
%type<statement_list_s> statement_list statement selection_statement iteration_statement switch_statement // no constructor
%type<result_s> res_id
%type<new_num_list_s> new_num_list
%type<id_arr_declare_s> id_arr_declare
%type<unit_declaration_s> unit_declaration
%type<elist_func_call_s> elist_func_call elist_super
%type<case_name_s> default_name case_name
%type<case_list_s> case_list case_list_minor case_statement default_statement
%type<unary_expression_s> unary_expression primary_expression
%%

program: statement_list;


function_declaration: function_head first_curly statement_list last_curly
{
	string tag = func_end_tag.get_func_end_tag();
	intermediate_output.gen(tag);
	if(!($3->continue_list.empty())){
		yyerror("unpatched continue statement left in the function\nAborting");
		exit(1);
	}
	if(!($3->break_list.empty())){
		yyerror("unpatched break statement left in the function\nAborting");
		exit(1);
	}
	//intermediate_output.patch_tag_no_put(tag,$3->break_list,intermediate_output.get_next()-1);
	intermediate_output.patch_tag_no_put(tag,$3->next,intermediate_output.get_next()-1);
	intermediate_output.gen_special("func","end","---","---");
	active_function_index = 0;
}
;

first_curly: OPEN_CURLY { level++;}
            ;

last_curly: CLOSE_CURLY
{
symbol_table.clear_var_list(active_function_index,level);
level--;
}
;

function_head: res_id OPEN_BRACKET parameter_list CLOSE_BRACKET
;

res_id: type ID {
    string s($2);
		if(s == "main"){
		 main_flag = true;
		}
    if(symbol_table.search_func(s) != -1){
      $$ = new result_(ERROR_TYPE);
      yyerror("this function is declared previously.Aborting at ");
			exit(0);
      active_function_index = -1;
    }
    else{
        $$ = new result_($1->type);
        active_function_index = symbol_table.add_function(s,$1->type);
        level = 1;
        string new_s = "func_" + s + ":";
        intermediate_output.gen(new_s);
				intermediate_output.gen_special("func","begin",s,"---");
    }
}
        ;

type: INT    {$$ = new type_(INT_TYPE);}
      |FLOAT {$$ = new type_(FLOAT_TYPE);}
      |VOID {$$ = new type_(VOID_TYPE);}
      ;

statement_list: statement_list M statement
{
	$$ = new statement_list_($1->can_appear_in_global);
	if(!($1->next.empty())){
		string tag = condition_tag.get_conditional_tag();
		intermediate_output.patch_tag(tag,$1->next,$2->position);
	}
	$$->next.insert($$->next.end(),$3->next.begin(),$3->next.end());
	$$->break_list.insert($$->break_list.end(),$1->break_list.begin(),$1->break_list.end());
	$$->break_list.insert($$->break_list.end(),$3->break_list.begin(),$3->break_list.end());
	$$->continue_list.insert($$->continue_list.end(),$1->continue_list.begin(),$1->continue_list.end());
	$$->continue_list.insert($$->continue_list.end(),$3->continue_list.begin(),$3->continue_list.end());

}
                | /* empty */
{
	$$ = new statement_list_(0);
	$$->next.clear();
	$$->break_list.clear();
	$$->continue_list.clear();
}
								;

statement: variable_declaration SEMI
{
	$$ = new statement_list_(0);
	$$->next.clear();
	$$->break_list.clear();
	$$->continue_list.clear();
}

				  | BREAK SEMI
{
$$ = new statement_list_(1);
$$->next.clear();
$$->break_list.push_back(intermediate_output.get_next());
intermediate_output.gen_special("goto","---","---","---");
$$->continue_list.clear();
}
					| CONTINUE SEMI
{
$$ = new statement_list_(1);
$$->next.clear();
$$->continue_list.push_back(intermediate_output.get_next());
intermediate_output.gen_special("goto","---","---","---");
$$->break_list.clear();

}
          |RETURN SEMI
{
	$$ = new statement_list_(1);
	$$->next.clear();
	$$->break_list.clear();
	$$->continue_list.clear();
	intermediate_output.gen_special("return","---","---","---");
}
          |RETURN conditional_expression SEMI
{
	$$ = new statement_list_(1);
	$$->next.clear();
	$$->break_list.clear();
	$$->continue_list.clear();
	intermediate_output.gen_special("return",$2->temporary_name,"---","---");
}
          |selection_statement
{
	$$ = new statement_list_(1);
	$$->error = false;
	$$->next.insert($$->next.end(),$1->next.begin(),$1->next.end());
	$$->break_list.insert($$->break_list.end(),$1->break_list.begin(),$1->break_list.end());
	$$->continue_list.insert($$->continue_list.end(),$1->continue_list.begin(),$1->continue_list.end());
	}
          |iteration_statement
{
	$$ = new statement_list_(1);
	$$->next.insert($$->next.end(),$1->next.begin(),$1->next.end());
	$$->break_list.clear();
	$$->continue_list.clear();
}
          |assignment_statement SEMI
{
	$$ = new statement_list_(0);
	$$->next.clear();
	$$->break_list.clear();
	$$->continue_list.clear();
}
          |first_curly statement_list last_curly
{
	$$ = new statement_list_(0);
	$$->error = false;
	$$->next.insert($$->next.end(),$2->next.begin(),$2->next.end());
	$$->break_list.insert($$->break_list.end(),$2->break_list.begin(),$2->break_list.end());
	$$->continue_list.insert($$->continue_list.end(),$2->continue_list.begin(),$2->continue_list.end());
}
					| switch_statement
{
	$$ = new statement_list_(1);
	$$->error = false;
	$$->next.insert($$->next.end(),$1->next.begin(),$1->next.end());
	$$->break_list.insert($$->break_list.end(),$1->break_list.begin(),$1->break_list.end());
	$$->continue_list.insert($$->continue_list.end(),$1->continue_list.begin(),$1->continue_list.end());
}

          | function_declaration

{
	if(active_function_index != 0){
			yyerror("can not define function within a function\nAborting");
			exit(1);
	}
	$$ = new statement_list_(2);
	$$->next.clear();
	$$->break_list.clear();
	$$->continue_list.clear();
}
;

selection_statement: ifexp  statement   ELSE N M statement
{
	$$= new statement_list_(1);
	if(active_function_index <= 0){
			yyerror("can not define selection statement globally\nAborting");
			exit(1);
	}

	string tag = condition_tag.get_conditional_tag();
	intermediate_output.patch_tag(tag,$1->false_list,$5->position);
	$$->break_list.insert($$->break_list.end(),$2->break_list.begin(),$2->break_list.end());
	$$->continue_list.insert($$->continue_list.end(),$2->continue_list.begin(),$2->continue_list.end());
	$$->break_list.insert($$->break_list.end(),$6->break_list.begin(),$6->break_list.end());
	$$->continue_list.insert($$->continue_list.end(),$6->continue_list.begin(),$6->continue_list.end());
	$$->next.insert($$->next.end(),$2->next.begin(),$2->next.end());
	$$->next.insert($$->next.end(),$6->next.begin(),$6->next.end());
	$$->next.insert($$->next.end(),$4->next.begin(),$4->next.end());
}
                    |ifexp  statement %prec "IFX"
{
		$$= new statement_list_(1);
		if(active_function_index <= 0){
				yyerror("can not define selection statement globally\nAborting");
				exit(1);
		}
		$$->break_list.insert($$->break_list.end(),$2->break_list.begin(),$2->break_list.end());
		$$->continue_list.insert($$->continue_list.end(),$2->continue_list.begin(),$2->continue_list.end());
		$$->next.insert($$->next.end(),$1->false_list.begin(),$1->false_list.end());
		$$->next.insert($$->next.end(),$2->next.begin(),$2->next.end());
}
;

switch_statement : SWITCH OPEN_BRACKET normal_expression CLOSE_BRACKET OPEN_CURLY case_list CLOSE_CURLY
{
	$$ = new statement_list_(1);
	$$->next.insert($$->next.end(),$6->break_list.begin(),$6->break_list.end());
	$$->next.insert($$->next.end(),$6->next.begin(),$6->next.end());
	$$->break_list.clear();
	$$->continue_list.insert($$->continue_list.end(),$6->continue_list.begin(),$6->continue_list.end());
	if(active_function_index <= 0){
			yyerror("can not define  selection statement globally\nAborting");
			exit(1);
	}
 	intermediate_output.patch_switch_con($3->temporary_name,$6->false_list);
}
;
case_list : case_list_minor default_statement
{
	string patch_address_1 = condition_tag.get_conditional_tag();

	//cout<<patch_address_1 << "   "<<patch_address_2 <<endl;
	intermediate_output.patch_tag(patch_address_1,$1->next,$2->second_address); // same 1st address
	vector<int> temp_index;
	if(!($1->false_list.empty())) temp_index.push_back($1->false_list.back());
	intermediate_output.patch_tag(patch_address_1,temp_index,$2->first_address);

	$$ = new case_list_($2->first_address,$2->second_address);
	$$->false_list.insert($$->false_list.end(),$1->false_list.begin(),$1->false_list.end());
	$$->false_list.insert($$->false_list.end(),$2->false_list.begin(),$2->false_list.end());
	$$->next.insert($$->next.end(),$2->next.begin(),$2->next.end());
	$$->break_list.insert($$->break_list.end(),$1->break_list.begin(),$1->break_list.end());
	$$->break_list.insert($$->break_list.end(),$2->break_list.begin(),$2->break_list.end());
	$$->continue_list.insert($$->continue_list.end(),$1->continue_list.begin(),$1->continue_list.end());
	$$->continue_list.insert($$->continue_list.end(),$2->continue_list.begin(),$2->continue_list.end());
}
						| case_list_minor  %prec "IFS"
{
	$$ = new case_list_($1->first_address,$1->second_address);
	$$->false_list.insert($$->false_list.end(),$1->false_list.begin(),$1->false_list.end());
	$$->break_list.insert($$->break_list.end(),$1->break_list.begin(),$1->break_list.end());
	$$->continue_list.insert($$->continue_list.end(),$1->continue_list.begin(),$1->continue_list.end());
	$$->next.insert($$->next.end(),$1->next.begin(),$1->next.end());
	// special case to handle last false list
	if(!($$->false_list.empty())){
		$$->next.push_back($$->false_list.back());
	}
}

;
case_list_minor : case_list_minor case_statement
{
	string patch_address_1 = condition_tag.get_conditional_tag();
	string patch_address_2 = condition_tag.get_conditional_tag();
  intermediate_output.patch_tag(patch_address_2,$1->next,$2->second_address);
	vector<int> temp_index;
	if(!($1->false_list.empty())) temp_index.push_back($1->false_list.back());
	intermediate_output.patch_tag(patch_address_1,temp_index,$2->first_address);


	$$ = new case_list_($2->first_address,$2->second_address);
	$$->false_list.insert($$->false_list.end(),$1->false_list.begin(),$1->false_list.end());
	$$->false_list.insert($$->false_list.end(),$2->false_list.begin(),$2->false_list.end());
	$$->next.insert($$->next.end(),$2->next.begin(),$2->next.end());
	$$->break_list.insert($$->break_list.end(),$1->break_list.begin(),$1->break_list.end());
	$$->break_list.insert($$->break_list.end(),$2->break_list.begin(),$2->break_list.end());
	$$->continue_list.insert($$->continue_list.end(),$1->continue_list.begin(),$1->continue_list.end());
	$$->continue_list.insert($$->continue_list.end(),$2->continue_list.begin(),$2->continue_list.end());
}

									| case_statement
{
	$$ = new case_list_ ($1->first_address,$1->second_address);
	$$->false_list.insert($$->false_list.end(),$1->false_list.begin(),$1->false_list.end());
	$$->next.insert($$->next.end(),$1->next.begin(),$1->next.end());
	$$->break_list.insert($$->break_list.end(),$1->break_list.begin(),$1->break_list.end());
	$$->continue_list.insert($$->continue_list.end(),$1->continue_list.begin(),$1->continue_list.end());
}
									;

default_statement : default_name statement
{
	$$ = new case_list_($1->first_address,$1->first_address);
	$$->false_list.clear();
	int normal_jump = intermediate_output.get_next();
	intermediate_output.gen_special("goto","---","---","---");
	$$->next.insert($$->next.end(),$2->next.begin(),$2->next.end());
	$$->next.push_back(normal_jump);
	$$->break_list.insert($$->break_list.end(),$2->break_list.begin(),$2->break_list.end());
	$$->false_list.clear();
	$$->continue_list.insert($$->continue_list.end(),$2->continue_list.begin(),$2->continue_list.end());
}
;
default_name : DEFAULT COLON
{
	$$ = new case_name_(intermediate_output.get_next());
	intermediate_output.gen("");
}
;

case_statement : case_name  normal_expression COLON  N_new M statement
{
	$$ = new case_list_($1->first_address,$5->position);
	$$->false_list.push_back($4->position);
	intermediate_output.back_patch_special("!=",$2->temporary_name,"---","---",$4->position);

	int normal_jump = intermediate_output.get_next();
	intermediate_output.gen_special("goto","---","---","---");
	$$->next.insert($$->next.end(),$6->next.begin(),$6->next.end());
	$$->next.push_back(normal_jump);
	$$->break_list.insert($$->break_list.end(),$6->break_list.begin(),$6->break_list.end());
	$$->continue_list.insert($$->continue_list.end(),$6->continue_list.begin(),$6->continue_list.end());
}
;
case_name : CASE
{
	$$ = new case_name_(intermediate_output.get_next());
	intermediate_output.gen("");
}
;
/* switch case statement left */

ifexp: IF OPEN_BRACKET assignment_statement CLOSE_BRACKET
{
	if($3->type!= ERROR_TYPE){
		$$ = new ifexp_(intermediate_output.get_next());
		intermediate_output.gen_special("==",$3->temporary_var_name,"0","---");
	}
	else{
		$$ = new ifexp_(-1);
		yyerror("unknown expression in used with if\nAborting");
		exit(1);
	}
}

;

iteration_statement: whileexp statement
{
	$$ = new statement_list_(1);
	string tag = loop_tag.get_loop_tag();
	intermediate_output.patch_tag(tag,$2->next,$1->jump_back_address);
	intermediate_output.patch_tag_no_put(tag,$2->continue_list,$1->jump_back_address);
	intermediate_output.gen_special("goto","---","---",tag);
	$$->break_list.clear();
	$$->continue_list.clear();
	$$->next.insert($$->next.end(),$1->false_list.begin(),$1->false_list.end());
	$$->next.insert($$->next.end(),$2->break_list.begin(),$2->break_list.end());

}
                    |forexp M assignment_statement M M CLOSE_BRACKET statement
{
	if($3->type == ERROR_TYPE){
		yyerror("unknown expression is used with while\nAborting");
		exit(1);
	}
	$$ = new statement_list_(1);
	string tag = loop_tag.get_loop_tag();
	intermediate_output.patch_tag(tag,$7->next,$2->position);
	intermediate_output.patch_tag_no_put(tag,$7->continue_list,$2->position);
	intermediate_output.gen_special("goto","---","---",tag);
	$$->break_list.clear();
	$$->continue_list.clear();
	string tag1 = loop_tag.get_loop_tag();
	intermediate_output.put_tag($1->jump_back_address,tag1);
	intermediate_output.gen_at_pos("goto --- --- "+tag1,$4->position);
 	string tag2 = loop_tag.get_loop_tag();
	vector<int> temp;
	if(!($1->false_list.empty())){
		temp.push_back(*($1->false_list.begin()) + 1);
		intermediate_output.patch_tag(tag2,temp,$5->position);
	}
	$$->next.insert($$->next.end(),$1->false_list.begin(),$1->false_list.end());
	$$->next.insert($$->next.end(),$7->break_list.begin(),$7->break_list.end());
}
										;

whileexp: WHILE M OPEN_BRACKET assignment_statement CLOSE_BRACKET
{
	if(active_function_index <= 0){
		yyerror("can not define loops globally\nAborting");
		exit(1);
	}
	if($4->type != ERROR_TYPE){
		$$ = new loopexp_(intermediate_output.get_next(),$2->position);
		intermediate_output.gen_special("==",$4->temporary_var_name,"0","---");
	}
	else{
		yyerror("unknown expression is used with while\nAborting");
		exit(1);
	}
}
;

forexp: FOR OPEN_BRACKET assignment_statement SEMI M assignment_statement SEMI
{
	if(active_function_index <= 0){
		yyerror("can not define loops globally\nAborting");
		exit(1);
	}
	if($3->type != ERROR_TYPE && $6->type != ERROR_TYPE){
		$$ = new loopexp_ (intermediate_output.get_next(),$5->position);
		intermediate_output.gen_special("==",$6->temporary_var_name,"0","---");
		intermediate_output.gen_special("goto","---","---","---");
	}
	else{
		yyerror("unknown expression is used with for\nAborting");
		exit(1);
	}
}

;

N_new : /*empty */
{
	$$ = new M_(intermediate_output.get_next());
	intermediate_output.gen("");
}

M: /*empty*/
{
 $$ = new M_(intermediate_output.get_next());
 intermediate_output.gen("");
}
;

N: /*empty*/
{
$$ = new N_ (intermediate_output.get_next());
intermediate_output.gen_special("goto","---","---","---");
}
;

conditional_expression: conditional_expression AND_OP expression
{
if($1->type == VOID_TYPE){
	yyerror("Trying to use and operator with a void data type");
	$1->type = ERROR_TYPE;
}
if($1->type == FLOAT_ADDRESS_TYPE || $1->type == INT_ADDRESS_TYPE){
	yyerror("Trying to use and operator with a pointer");
	$1->type = ERROR_TYPE;
}
if($3->type == VOID_TYPE){
	yyerror("Trying to use and operator with a void data type");
	$3->type = ERROR_TYPE;
}
if($3->type == FLOAT_ADDRESS_TYPE || $3->type == INT_ADDRESS_TYPE){
	yyerror("Trying to use and operator with a pointer");
	$3->type = ERROR_TYPE;
}
 	int temp_type = get_compatible_type_bool_only($1->type,$3->type);
 	$$ = new conditional_expression_(temp_type);
 	std::ostringstream out;
 	if(temp_type != ERROR_TYPE){
		intermediate_output.gen_special("&&",$1->temporary_name,$3->temporary_name,$$->temporary_name);
 	}
	else{
		if($1->type != ERROR_TYPE && $3->type != ERROR_TYPE){
				yyerror("Expected boolean data types for both operand");
		}
	}
}
                        |conditional_expression OR_OP expression
{
if($1->type == VOID_TYPE){
	yyerror("Trying to use or operator with a void data type");
	$1->type = ERROR_TYPE;
}
if($1->type == FLOAT_ADDRESS_TYPE || $1->type == INT_ADDRESS_TYPE){
	yyerror("Trying to use or operator with a pointer");
	$1->type = ERROR_TYPE;
}
if($3->type == VOID_TYPE){
	yyerror("Trying to use or operator with a void data type");
	$3->type = ERROR_TYPE;
}
if($3->type == FLOAT_ADDRESS_TYPE || $3->type == INT_ADDRESS_TYPE){
	yyerror("Trying to use or operator with a pointer");
	$3->type = ERROR_TYPE;
}
 	int temp_type = get_compatible_type_bool_only($1->type,$3->type);
 	$$ = new conditional_expression_(temp_type);
 	std::ostringstream out;
 	if(temp_type != ERROR_TYPE){
	 	intermediate_output.gen_special("&&",$1->temporary_name,$3->temporary_name,$$->temporary_name);
 	}
	else{
		if($1->type != ERROR_TYPE && $3->type != ERROR_TYPE){
				yyerror("Expected boolean data types for both operand");
		}
	}
}

                        |expression
{
	$$ = new conditional_expression_($1->type,$1->temporary_name);
}

												;

expression: rel_expression
{
	$$ = new conditional_expression_($1->type,$1->temporary_name);
}
          |normal_expression
{
	$$ = new conditional_expression_($1->type,$1->temporary_name);
}
					;

rel_expression: normal_expression GT normal_expression
{
if($1->type == VOID_TYPE){
	yyerror("Trying to compare a void data type");
	$1->type = ERROR_TYPE;
}
if($1->type == FLOAT_ADDRESS_TYPE || $1->type == INT_ADDRESS_TYPE){
	yyerror("Trying to compare a pointer");
	$1->type = ERROR_TYPE;
}
if($3->type == VOID_TYPE){
	yyerror("Trying to compare a void data type");
	$3->type = ERROR_TYPE;
}
if($3->type == FLOAT_ADDRESS_TYPE || $3->type == INT_ADDRESS_TYPE){
	yyerror("Trying to compare a pointer");
	$3->type = ERROR_TYPE;
}
	int temp_type = get_compatible_type_rel_op($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		intermediate_output.gen_relational_op(">",$1->temporary_name,$3->temporary_name,$$->temporary_name);
	}
	else{
		if($1->type != ERROR_TYPE &&  $3->type != ERROR_TYPE){
			if($1->type == BOOL_TYPE &&  $3->type != BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
			if($1->type != BOOL_TYPE &&  $3->type == BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
		}
	}

}

                |normal_expression LT normal_expression

{
if($1->type == VOID_TYPE){
	yyerror("Trying to compare a void data type");
	$1->type = ERROR_TYPE;
}
if($1->type == FLOAT_ADDRESS_TYPE || $1->type == INT_ADDRESS_TYPE){
	yyerror("Trying to compare a pointer");
	$1->type = ERROR_TYPE;
}
if($3->type == VOID_TYPE){
	yyerror("Trying to compare a void data type");
	$3->type = ERROR_TYPE;
}
if($3->type == FLOAT_ADDRESS_TYPE || $3->type == INT_ADDRESS_TYPE){
	yyerror("Trying to compare a pointer");
	$3->type = ERROR_TYPE;
}
	int temp_type = get_compatible_type_rel_op($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
	intermediate_output.gen_relational_op("<",$1->temporary_name,$3->temporary_name,$$->temporary_name);
	}
	else{
		if($1->type != ERROR_TYPE &&  $3->type != ERROR_TYPE){
			if($1->type == BOOL_TYPE &&  $3->type != BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
			if($1->type != BOOL_TYPE &&  $3->type == BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
		}
	}

}

                |normal_expression GE_OP normal_expression
{
if($1->type == VOID_TYPE){
	yyerror("Trying to compare a void data type");
	$1->type = ERROR_TYPE;
}
if($1->type == FLOAT_ADDRESS_TYPE || $1->type == INT_ADDRESS_TYPE){
	yyerror("Trying to compare a pointer");
	$1->type = ERROR_TYPE;
}
if($3->type == VOID_TYPE){
	yyerror("Trying to compare a void data type");
	$3->type = ERROR_TYPE;
}
if($3->type == FLOAT_ADDRESS_TYPE || $3->type == INT_ADDRESS_TYPE){
	yyerror("Trying to compare a pointer");
	$3->type = ERROR_TYPE;
}
	int temp_type = get_compatible_type_rel_op($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		intermediate_output.gen_relational_op(">=",$1->temporary_name,$3->temporary_name,$$->temporary_name);
	}
	else{
		if($1->type != ERROR_TYPE &&  $3->type != ERROR_TYPE){
			if($1->type == BOOL_TYPE &&  $3->type != BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
			if($1->type != BOOL_TYPE &&  $3->type == BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
		}
	}

}

                |normal_expression LE_OP normal_expression
{
if($1->type == VOID_TYPE){
	yyerror("Trying to compare a void data type");
	$1->type = ERROR_TYPE;
}
if($1->type == FLOAT_ADDRESS_TYPE || $1->type == INT_ADDRESS_TYPE){
	yyerror("Trying to compare a pointer");
	$1->type = ERROR_TYPE;
}
if($3->type == VOID_TYPE){
	yyerror("Trying to compare a void data type");
	$3->type = ERROR_TYPE;
}
if($3->type == FLOAT_ADDRESS_TYPE || $3->type == INT_ADDRESS_TYPE){
	yyerror("Trying to compare a pointer");
	$3->type = ERROR_TYPE;
}
	int temp_type = get_compatible_type_rel_op($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		intermediate_output.gen_relational_op("<=",$1->temporary_name,$3->temporary_name,$$->temporary_name);
	}
	else{
		if($1->type != ERROR_TYPE &&  $3->type != ERROR_TYPE){
			if($1->type == BOOL_TYPE &&  $3->type != BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
			if($1->type != BOOL_TYPE &&  $3->type == BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
		}
	}

}
                |normal_expression EQ_OP normal_expression
{
if($1->type == VOID_TYPE){
	yyerror("Trying to compare a void data type");
	$1->type = ERROR_TYPE;
}
if($1->type == FLOAT_ADDRESS_TYPE || $1->type == INT_ADDRESS_TYPE){
	yyerror("Trying to compare a pointer");
	$1->type = ERROR_TYPE;
}
if($3->type == VOID_TYPE){
	yyerror("Trying to compare a void data type");
	$3->type = ERROR_TYPE;
}
if($3->type == FLOAT_ADDRESS_TYPE || $3->type == INT_ADDRESS_TYPE){
	yyerror("Trying to compare a pointer");
	$3->type = ERROR_TYPE;
}
	int temp_type = get_compatible_type_rel_op($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
	intermediate_output.gen_relational_op("==",$1->temporary_name,$3->temporary_name,$$->temporary_name);
	}
	else{
		if($1->type != ERROR_TYPE &&  $3->type != ERROR_TYPE){
			if($1->type == BOOL_TYPE &&  $3->type != BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
			if($1->type != BOOL_TYPE &&  $3->type == BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
		}
	}

}
                |normal_expression NE_OP normal_expression
{
if($1->type == VOID_TYPE){
	yyerror("Trying to compare a void data type");
	$1->type = ERROR_TYPE;
}
if($1->type == FLOAT_ADDRESS_TYPE || $1->type == INT_ADDRESS_TYPE){
	yyerror("Trying to compare a pointer");
	$1->type = ERROR_TYPE;
}
if($3->type == VOID_TYPE){
	yyerror("Trying to compare a void data type");
	$3->type = ERROR_TYPE;
}
if($3->type == FLOAT_ADDRESS_TYPE || $3->type == INT_ADDRESS_TYPE){
	yyerror("Trying to compare a pointer");
	$3->type = ERROR_TYPE;
}
	int temp_type = get_compatible_type_rel_op($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		intermediate_output.gen_relational_op("!=",$1->temporary_name,$3->temporary_name,$$->temporary_name);
	}
	else{
		if($1->type != ERROR_TYPE &&  $3->type != ERROR_TYPE){
			if($1->type == BOOL_TYPE &&  $3->type != BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
			if($1->type != BOOL_TYPE &&  $3->type == BOOL_TYPE){
				yyerror("Incompatible data types with relational operator");
			}
		}
	}
}
								;

normal_expression: normal_expression PLUS term
{
	if($1->type == VOID_TYPE){
		yyerror("Trying to add a void data type");
		$1->type = ERROR_TYPE;
	}
	if($1->type == FLOAT_ADDRESS_TYPE || $1->type == INT_ADDRESS_TYPE){
		yyerror("Trying to add a pointer");
		$1->type = ERROR_TYPE;
	}
	if($3->type == VOID_TYPE){
		yyerror("Trying to add a void data type");
		$3->type = ERROR_TYPE;
	}
	if($3->type == FLOAT_ADDRESS_TYPE || $3->type == INT_ADDRESS_TYPE){
		yyerror("Trying to add a pointer");
		$3->type = ERROR_TYPE;
	}

	int temp_type = get_compatible_type_non_bool($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		intermediate_output.gen_special("+",$1->temporary_name,$3->temporary_name,$$->temporary_name);

	}
	else{
		if($1->type == BOOL_TYPE &&  $3->type == BOOL_TYPE){
			yyerror("Trying to add with a boolean data type");
		}
	}
}
                  |normal_expression MINUS term
{
	if($1->type == VOID_TYPE){
		yyerror("Trying to subtract a void data type");
		$1->type = ERROR_TYPE;
	}
	if($1->type == FLOAT_ADDRESS_TYPE || $1->type == INT_ADDRESS_TYPE){
		yyerror("Trying to subtract a pointer");
		$1->type = ERROR_TYPE;
	}
	if($3->type == VOID_TYPE){
		yyerror("Trying to subtract a void data type");
		$3->type = ERROR_TYPE;
	}
	if($3->type == FLOAT_ADDRESS_TYPE || $3->type == INT_ADDRESS_TYPE){
		yyerror("Trying to subtract a pointer");
		$3->type = ERROR_TYPE;
	}
	int temp_type = get_compatible_type_non_bool($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		intermediate_output.gen_special("-",$1->temporary_name,$3->temporary_name,$$->temporary_name);
	}
	else{
		if($1->type == BOOL_TYPE &&  $3->type == BOOL_TYPE){
			yyerror("Trying to subtract with a boolean data type");
		}
	}
}

                  |term
{
	$$ = new conditional_expression_($1->type,$1->temporary_name);
}

									;

term: term STAR factor
{
	if($1->type == VOID_TYPE){
		yyerror("Trying to multiply a void data type");
		$1->type = ERROR_TYPE;
	}
	if($1->type == FLOAT_ADDRESS_TYPE || $1->type == INT_ADDRESS_TYPE){
		yyerror("Trying to multiply a pointer");
		$1->type = ERROR_TYPE;
	}
	if($3->type == VOID_TYPE){
		yyerror("Trying to multiply a void data type");
		$3->type = ERROR_TYPE;
	}
	if($3->type == FLOAT_ADDRESS_TYPE || $3->type == INT_ADDRESS_TYPE){
		yyerror("Trying to multiply a pointer");
		$3->type = ERROR_TYPE;
	}
	int temp_type = get_compatible_type_non_bool($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		intermediate_output.gen_special("*",$1->temporary_name,$3->temporary_name,$$->temporary_name);
	}
	else{
		if($1->type == BOOL_TYPE &&  $3->type == BOOL_TYPE){
			yyerror("Trying to multiply with a boolean data type");
		}
	}
}
      |term DIVIDE factor
{
	if($1->type == VOID_TYPE){
		yyerror("Trying to divide a void data type");
		$1->type = ERROR_TYPE;
	}
	if($1->type == FLOAT_ADDRESS_TYPE || $1->type == INT_ADDRESS_TYPE){
		yyerror("Trying to divide a pointer");
		$1->type = ERROR_TYPE;
	}
	if($3->type == VOID_TYPE){
		yyerror("Trying to divide a void data type");
		$3->type = ERROR_TYPE;
	}
	if($3->type == FLOAT_ADDRESS_TYPE || $3->type == INT_ADDRESS_TYPE){
		yyerror("Trying to divide a pointer");
		$3->type = ERROR_TYPE;
	}
	int temp_type = get_compatible_type_non_bool($1->type,$3->type);
	$$ = new conditional_expression_(temp_type);
	std::ostringstream out;
	if(temp_type != ERROR_TYPE){
		intermediate_output.gen_special("/",$1->temporary_name,$3->temporary_name,$$->temporary_name);
	}
	else{
		if($1->type == BOOL_TYPE &&  $3->type == BOOL_TYPE){
		 	yyerror("Trying to divide with a boolean data type");
		}
	}
}

      |factor
{
	$$ = new conditional_expression_($1->type,$1->temporary_name);

}

			;

factor: unary_expression
{
	$$ = new conditional_expression_($1->type,$1->temporary_name);
}
;

unary_expression: primary_expression
{
	$$ = new unary_expression_($1->type,$1->temporary_name);
	$$->var = $1->var;
}
                |MINUS unary_expression %prec UMINUS
{
	if($2->type == VOID_TYPE){
		yyerror("Trying to negate a void data type");
		$2->type = ERROR_TYPE;
	}
	if($2->type == FLOAT_ADDRESS_TYPE || $2->type == INT_ADDRESS_TYPE){
	 	yyerror("Trying to negate a pointer");
	 	$2->type = ERROR_TYPE;
 	}
	if($2->type != BOOL_TYPE){
		$$ = new unary_expression_($2->type);
		$$->var = $2->var;
		std::ostringstream out;
		if($2->type != ERROR_TYPE ){
			intermediate_output.gen_special("UMINUS",$2->temporary_name,"---",$$->temporary_name);
		}
	}
	else{
		yyerror("Trying to negate a boolean data type");
		$$ = new unary_expression_(ERROR_TYPE);
		$$->var = NULL;
	}
}
                |NOT unary_expression
{
	std::ostringstream out;
	if($2->type == VOID_TYPE){
		yyerror("can not use not operator on void data type");
		$2->type = ERROR_TYPE;
	}
	if($2->type == FLOAT_ADDRESS_TYPE || $2->type == INT_ADDRESS_TYPE){
		yyerror("can not use not operator on pointers");
		$2->type = ERROR_TYPE;
	}

	if($2->type == FLOAT_TYPE  || $2->type == INT_TYPE ){
		$$ = new unary_expression_(ERROR_TYPE);
		yyerror("can not use not operator on a float or int data type");
		$$->var = NULL;
	}
	else{
				$$ = new unary_expression_($2->type);
				$$->var = $2->var;
		}
	if($2->type != ERROR_TYPE && $2->type != FLOAT_TYPE && $2->type != INT_TYPE ){
			intermediate_output.gen_special("NOT",$2->temporary_name,"---",$$->temporary_name);

	}
}
                |DEC_OP unary_expression
{
	if($2->type == VOID_TYPE){
		yyerror("Trying to decrement a void data type");
		$2->type = ERROR_TYPE;
	}
	if($2->type == FLOAT_ADDRESS_TYPE || $2->type == INT_ADDRESS_TYPE){
		yyerror("decrementing pointers not allowed");
		$2->type = ERROR_TYPE;
	}
	if($2->type != BOOL_TYPE){
		$$ = new unary_expression_($2->type);
		$$->var = $2->var;
		std::ostringstream out;
		if($2->type != ERROR_TYPE){
			intermediate_output.gen_special("-",$2->temporary_name,"1",$$->temporary_name);
			intermediate_output.gen_special("=",$$->temporary_name,"---",$2->temporary_name);
			$$->temporary_name = $2->temporary_name;
			if($2->var != NULL){
				intermediate_output.gen_special("=",$2->temporary_name,"---",$2->var->name+"_"+to_string($2->var->offset));
			}
		}
	}
	else{
		yyerror("Trying to decrement a boolean data type");
		$$ = new unary_expression_(ERROR_TYPE);
		$$->var = NULL;
	}

}
                |INC_OP unary_expression
{
	if($2->type == VOID_TYPE){
		yyerror("Trying to increment a void data type");
		$2->type = ERROR_TYPE;
	}
	if($2->type == FLOAT_ADDRESS_TYPE || $2->type == INT_ADDRESS_TYPE){
		yyerror("incrementing pointers not allowed");
		$2->type = ERROR_TYPE;
	}

	if($2->type != BOOL_TYPE){
		$$ = new unary_expression_($2->type);
		$$->var = $2->var;
		std::ostringstream out;
		if($2->type != ERROR_TYPE){
			intermediate_output.gen_special("+",$2->temporary_name,"1",$$->temporary_name);
			intermediate_output.gen_special("=",$$->temporary_name,"---",$2->temporary_name);
			$$->temporary_name = $2->temporary_name;
			if($2->var != NULL ){
				intermediate_output.gen_special("=",$2->temporary_name,"---",$2->var->name+"_"+to_string($2->var->offset));
			}
		}
	}
	else{
		yyerror("Trying to increment a boolean data type");
		$$ = new unary_expression_(ERROR_TYPE);
		$$->var = NULL;
	}
}

								;

primary_expression: NUM
{
	$$ = new unary_expression_(INT_TYPE);
	intermediate_output.gen_special("=",to_string($1),"---",$$->temporary_name);
	$$->var = NULL;
}


                    |REAL
{
	$$ = new unary_expression_(FLOAT_TYPE);
	intermediate_output.gen_special("=",to_string($1),"---",$$->temporary_name);
	$$->var = NULL;
}

                    | id_arr
{
/* don't put error msg here*/
if($1->var == NULL){
		//yyerror("The used variable is not declared");
		$$ = new unary_expression_(ERROR_TYPE);
		$$->var = NULL;
}
else{
		$$ = new unary_expression_($1->var->eletype);
		std::ostringstream out;
		if($1->var->type == SIMPLE){
			out << "= " << $1->var->name <<"_"<< $1->var->offset << " --- " << $$->temporary_name;
			$$->var = $1->var;
		}
		else{
			string temp_address = "T" + to_string(global_temp);
			global_temp ++;
			intermediate_output.gen_special("addr",$1->var->name+"_"+to_string($1->var->offset),"---",temp_address);
			out << "= " <<temp_address<< "["<<$1->offset_temp<<"] " << $$->temporary_name;
			$$->var = $1->var;
		}
		string s = out.str();
		intermediate_output.gen(s);
}

}
                    |OPEN_BRACKET conditional_expression CLOSE_BRACKET
{
  $$ = new unary_expression_($2->type,$2->temporary_name);
	$$->var = NULL;
}
									| func_call
{
	$$ = new unary_expression_ ($1->type,$1->temporary_name);
	$$->var = NULL;
}
									;



elist: elist OPEN_SQUARE expression CLOSE_SQUARE
{
	$$ = new elist_();
	$$->name_list.insert($$->name_list.end(),$1->name_list.begin(),$1->name_list.end());
	if($3->type != INT_TYPE){
		$$->type = ERROR_TYPE;
		if($3->type != ERROR_TYPE){
			yyerror("Expected an integer data type for array index");
		}
		$$->name_list.push_back("ERR");
	}
	else{
		$$->type = INT_TYPE;
		$$->name_list.push_back($3->temporary_name);
	}
}
      |OPEN_SQUARE expression CLOSE_SQUARE
{
	$$ = new elist_();
	if($2->type != INT_TYPE){
		$$->type = ERROR_TYPE;
		if($2->type != ERROR_TYPE){
			yyerror("Expected an integer data type for array index");
		}
		$$->name_list.push_back("ERR");
	}
	else{
		$$->type = INT_TYPE;
		$$->name_list.push_back($2->temporary_name);
	}
}

			;
func_call : ID OPEN_BRACKET elist_super CLOSE_BRACKET
{
 string s($1);
 call_function_index = symbol_table.search_func(s);
 if(call_function_index != -1){
 		int temp_type = symbol_table.check_param_compatible(call_function_index,$3->type_list); // this function prints error msgs
		if(temp_type != ERROR_TYPE){
			string result_func = symbol_table.genarate_function_call(call_function_index,$3);
			$$ = new conditional_expression_(temp_type,result_func);
		}
		else{
			$$ = new conditional_expression_(ERROR_TYPE,"ERR");
		}
 }
 else{
 		yyerror("function "+s+ " is not declared");
		$$ = new conditional_expression_(ERROR_TYPE,"ERR");
 }
}
;

elist_super : elist_func_call
{
	$$ = new elist_func_call_();
	$$->type_list = $1->type_list;
	$$->name_list = $1->name_list;
}
 						| /* empty */
{
	$$ = new elist_func_call_();
	$$->type_list.clear();
	$$->name_list.clear();
}
						;

elist_func_call :	elist_func_call COMMA expression
{
	$$ = new elist_func_call_();
	$$->type_list.insert($$->type_list.end(),$1->type_list.begin(),$1->type_list.end());
	$$->name_list.insert($$->name_list.end(),$1->name_list.begin(),$1->name_list.end());
	$$->type_list.push_back($3->type);
	$$->name_list.push_back($3->temporary_name);
}
									| expression
{
	$$ = new elist_func_call_();
	$$->type_list.push_back($1->type);
	$$->name_list.push_back($1->temporary_name);
}
									;

assignment_statement: id_arr ASSIGN conditional_expression
{ /* don't put error msg here */
	if($1->var != NULL){
			if($1->var->eletype == FLOAT_ADDRESS_TYPE || $1->var->eletype == INT_ADDRESS_TYPE){
				yyerror("we don't support assigning pointers");
				$1->var->eletype = ERROR_TYPE;
			}
			if($1->var->eletype == VOID_TYPE){
				yyerror("Trying to assign a void type");
				$1->var->eletype = ERROR_TYPE;
			}
			int temp_type = get_compatible_type_non_bool($1->var->eletype,$3->type);
			if(temp_type == ERROR_TYPE){
				if($1->var->type != ERROR_TYPE && $3->type != ERROR_TYPE){
						yyerror("Incompatible data types are used for assignment");
				}
				$$ = new assignment_statement_(ERROR_TYPE,"ERR");
			}
			else{
				if($1->var->type == SIMPLE){
					intermediate_output.gen_special("=",$3->temporary_name,"---",$1->var->name+"_"+to_string($1->var->offset));
				}
				else{
					std::ostringstream out;
					string temp_address = "T" + to_string(global_temp);
					global_temp ++;
					intermediate_output.gen_special("addr",$1->var->name+"_"+to_string($1->var->offset),"---",temp_address);
					out << "= " << $3->temporary_name <<" " << temp_address<< "["<<$1->offset_temp<<"] " ;
					string s_1 = out.str();
					intermediate_output.gen(s_1);
				}
				$$ = new assignment_statement_(temp_type,"ERR");
			}
	}
	else{
			$$ = new assignment_statement_(ERROR_TYPE,"ERR");
	}
}
					  |	conditional_expression
{
		$$ = new assignment_statement_($1->type,$1->temporary_name);
}
					  | /* empty */
{
// needs attention
	$$ = new assignment_statement_(VOID_TYPE,"ERR");
}

					  ;

variable_declaration: type varlist
{
	if(active_function_index != -1 ){
		symbol_table.patch_variable(active_function_index,$2->list_of_indexes,$1->type);
 	}
}

;
/* check where id_arr is used it is null or not */
id_arr: ID
{
	if(active_function_index != -1){
		string s($1);
		variable * var =symbol_table.search_variable_global(active_function_index,s,level);
		if(var == NULL){
			std::ostringstream out1;
			out1<<"varible with name "<<s<< " should be declared before use";
			string s_1 = out1.str();
			yyerror(s_1);
		}
		else{
			if(var-> type != SIMPLE){
				if(var->eletype == FLOAT_TYPE){
					var->eletype = FLOAT_ADDRESS_TYPE;
					var->type = SIMPLE;
				}
				if(var->eletype == INT_TYPE){
					var->eletype = INT_ADDRESS_TYPE;
					var->type = SIMPLE;
				}
				if(var->eletype != INT_TYPE && var->eletype != FLOAT_TYPE){
					var = NULL;
				}
			}
		}
		$$ = new id_arr_(var,"NONE");
	}
}
      |ID elist
{
	if(active_function_index != -1){
		string s($1);
		string offset_temp = "NONE";
		variable * var =symbol_table.search_variable_global(active_function_index,s,level);
		if(var == NULL){
			std::ostringstream out1;
			out1<<"varible with name "<<s<< " should be declared before use";
			string s_1 = out1.str();
			yyerror(s_1);
		}

		if(var != NULL){
			if(var->type != ARRAY){
				yyerror("variable "+ s + "is not array ");
				var = NULL;
			}
		}
		/* var != NULL signifies it is an array type */
		if(var != NULL){
			if($2->type == ERROR_TYPE || ($2->name_list.size() == 0) || ($2->name_list.size() != var->dimlist.size() ) ){
				var = NULL;
				std::ostringstream out1;
				out1<<"for variable "<<s<<" either array index is not integer " <<" or does not fit its declaration";
				string s_1 = out1.str();
				yyerror(s_1);
			}
			else{
					string temp_index = "T" + to_string(global_temp);
					global_temp ++;
					intermediate_output.gen_special("=",$2->name_list[0],"---",temp_index);
					string prev_index = temp_index;
					for(int i=1;i<$2->name_list.size();i++){
						string temp_index_new_1 = "T" + to_string(global_temp);
						global_temp ++;
						string temp_index_new_2 = "T" + to_string(global_temp);
						global_temp ++;
						intermediate_output.gen_special("*",prev_index,to_string(var->dimlist[i]),temp_index_new_1);
						intermediate_output.gen_special("+",temp_index_new_1,$2->name_list[i],temp_index_new_2);
						prev_index = temp_index_new_2;
					}
					string final_index = "T" + to_string(global_temp);
					global_temp++;
					string temp_final_result = "T" + to_string(global_temp);
					global_temp ++;
					if(var->eletype == FLOAT_TYPE){
						intermediate_output.gen_special("*",prev_index,to_string(FLOAT_TYPE_SIZE),final_index);
					}
					else {
						intermediate_output.gen_special("*",prev_index,to_string(INT_TYPE_SIZE),final_index);
					}
						offset_temp = final_index;
			}
		}
			$$ = new id_arr_(var,offset_temp);
	}
}
			;

/* storing -1 in place of index be careful */
id_arr_declare : ID
 {
  if(active_function_index != -1){
      string s($1);
      variable * v_temp = symbol_table.search_variable_current(active_function_index,s,level);
      vector<int> v;
      v.clear();
      if(v_temp == NULL){
          int index = symbol_table.add_variable(active_function_index,s,SIMPLE,v,level);
          $$ = new id_arr_declare_(index);
      }
      else{
          if(v_temp->level_of_declaration != level){
              if(level != 2){
                  int index = symbol_table.add_variable(active_function_index,s,SIMPLE,v,level);
                  $$ = new id_arr_declare_(index);
              }
              else{
                  if(symbol_table.search_parameter(active_function_index,s) == false){
                    int index = symbol_table.add_variable(active_function_index,s,SIMPLE,v,level);
                    $$ = new id_arr_declare_(index);
                  }
                  else{
                      yyerror("This variable is defined in this scope previously");
                      $$ = new id_arr_declare_(-1);
                  }
              }
          }
          else{
              yyerror("This variable is defined in this scope previously");
              $$ = new id_arr_declare_(-1);
          }
      }
  }
}
                | ID new_num_list{
if(active_function_index != -1){
      string s($1);
      variable * v_temp = symbol_table.search_variable_current(active_function_index,s,level);
      vector<int> v;
      v.clear();
      v = $2-> num_list;
      if(v_temp == NULL){
          int index = symbol_table.add_variable(active_function_index,s,ARRAY,v,level);
          $$ = new id_arr_declare_(index);
      }
      else{
          if(v_temp->level_of_declaration != level){
              if(level != 2){
                  int index = symbol_table.add_variable(active_function_index,s,ARRAY,v,level);
                  $$ = new id_arr_declare_(index);
              }
              else{
                  if(symbol_table.search_parameter(active_function_index,s) == false){
                    int index = symbol_table.add_variable(active_function_index,s,ARRAY,v,level);
                    $$ = new id_arr_declare_(index);
                  }
                  else{
                      yyerror("This variable is defined in this scope previously");
                      $$ = new id_arr_declare_(-1);
                  }
              }
          }
          else{
              yyerror("This variable is defined in this scope previously");
              $$ = new id_arr_declare_(-1);
          }
      }
  }
}

                ;

new_num_list : new_num_list  OPEN_SQUARE NUM CLOSE_SQUARE
{
      $$  = new new_num_list_();
      $$->num_list.insert($$->num_list.end(),$1->num_list.begin(),$1->num_list.end());
      $$->num_list.push_back($3);
}
               | OPEN_SQUARE NUM CLOSE_SQUARE
{
    $$  = new new_num_list_();
    $$->num_list.push_back($2);
}
               ;

parameter_list: param_decl
							{ $$ = new parameter_list_($1->no_of_parameter);
								symbol_table.patch_function_parameter_no(active_function_index,$$->no_of_parameter);
							}
              |/*empty*/
							{ $$ = new parameter_list_(0);
							 symbol_table.patch_function_parameter_no(active_function_index,$$->no_of_parameter);
							}
              ;

param_decl: param_decl COMMA unit_declaration

{
	if(active_function_index != -1){
	 	if($3->type != ERROR_TYPE){
	 		$$ = new parameter_list_($1->no_of_parameter + 1);;
	 	}
	 	else{
	  	$$ = new parameter_list_($1->no_of_parameter);
	 	}
	}
}


          |unit_declaration
{
if(active_function_index != -1){
	 if($1->type != ERROR_TYPE){
	 $$ = new parameter_list_(1);
	 }
	 else{
	  	$$ = new parameter_list_(0);
	 }
}
}
          ;

unit_declaration: type ID
{
	if(active_function_index != -1){
		string s($2);
		if(symbol_table.search_parameter(active_function_index,s) == false ){
			int index = symbol_table.add_parameter(active_function_index,s,SIMPLE,$1->type);
			$$ = new unit_declaration_ ($1->type);
		}
		else{
			yyerror("This parameter has been passed early");
			$$ = new unit_declaration_ (ERROR_TYPE);
			}
	}
}
                |type ID OPEN_SQUARE CLOSE_SQUARE
{
if(active_function_index != -1){
	string s($2);
	if(symbol_table.search_parameter(active_function_index,s) == false ){
		int index = symbol_table.add_parameter(active_function_index,s,ARRAY,$1->type);
		$$ = new unit_declaration_ ($1->type);
	}
	else{
			yyerror("This parameter has been passed early");
			$$ = new unit_declaration_ (ERROR_TYPE);
	}
}
}
               ;

varlist: varlist COMMA id_arr_declare
{
	  $$ = new varlist_();
		$$->list_of_indexes.insert($$->list_of_indexes.end(),$1->list_of_indexes.begin(),$1->list_of_indexes.end());
		$$->list_of_indexes.push_back($3->index_in_sym_tab);
}
        |id_arr_declare
{
    $$ = new varlist_();
		$$->list_of_indexes.push_back($1->index_in_sym_tab);
}

        ;

%%
#include <stdio.h>

int main(){

	yyparse();
	if(main_flag == false){
		cout<< "ERROR :: no main function found\n";
		exit(1);
	}
	if(total_error == false){
		intermediate_output.print();
	}	
}
